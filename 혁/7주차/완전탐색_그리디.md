## 📌 알고리즘 개념 정리

---

### 🔍 완전탐색 (Brute Force)

**정의**  
모든 경우의 수를 **전부 탐색**하여 정답을 찾는 방식.

**특징**
- 가능한 모든 경우를 시도 → **정확한 정답 보장**
- 시간 복잡도가 크기 때문에 **입력 크기가 작을 때** 적합
- 구현이 비교적 단순

**종류**
- 순열 (Permutation)
- 조합 (Combination)
- 중복 순열/조합
- 백트래킹 (Brute Force + 가지치기)

**장점**
- 확실하게 정답을 찾을 수 있음
- 코드가 간단하고 직관적

**단점**
- 시간 복잡도가 매우 큼 → 효율성 떨어짐

**예시**
- 비밀번호 찾기: 0000 ~ 9999 전부 시도
- 모든 경우의 수에서 최대/최소 찾기
- N과 M (백준의 순열/조합 문제들)

---

### 💡 그리디 알고리즘 (Greedy Algorithm)

**정의**  
매 순간 **가장 좋아 보이는 선택(탐욕적 선택)**을 하여 전체 문제의 해답을 찾는 방법.

**특징**
- **현재의 최적 선택**이 **전체 최적 해**로 이어진다는 전제가 필요
- 일반적으로 빠른 속도 (시간 복잡도 ↓)

**조건**
- **탐욕 선택 속성(Greedy Choice Property)**: 현재의 선택이 전체 최적에 영향을 줘야 함
- **최적 부분 구조(Optimal Substructure)**: 문제를 부분 문제로 나눌 수 있어야 함

**장점**
- 구현이 간단하고 빠름
- 완전탐색보다 훨씬 효율적

**단점**
- 항상 정답을 보장하지는 않음
- 문제의 특성을 잘 분석해야 적용 가능

**예시**
- 동전 거스름돈 문제 (단, 화폐 단위가 Greedy 조건을 만족할 때)
- 회의실 배정 문제
- 최소 회의실 문제
- 활동 선택 문제

---

### 🆚 완전탐색 vs 그리디

| 항목 | 완전탐색 | 그리디 |
|------|----------|--------|
| 정확성 | 항상 정답 보장 | 조건 만족 시 정답 보장 |
| 효율성 | 낮음 (시간 오래 걸림) | 높음 (빠름) |
| 사용 조건 | 작은 범위에서 사용 | 그리디 조건 만족 시 사용 |
| 구현 난이도 | 쉬움 | 중간 (조건 분석 필요) |


