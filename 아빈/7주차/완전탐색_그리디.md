## 완전탐색
### 완전탐색이란?
- 탐색 알고리즘 중 모든 경우의 수를 탐색하여 최적의 결과를 찾는 알고리즘
- 모든 경우의 수를 탐색하기 때문에 최적의 해를 항상 찾을 수 있다는 장점이 있지만, 그만큼 시간과 메모리 부담이 커질 수 있음
- 무식하게 푼다는 의미로 brute force라고도 한다.

### 완전탐색의 종류
- Brute Force
  - 모든 경우의 수를 탐색하며 원하는 결과를 얻는 알고리즘
  - 가능한 모든 경우를 다 검사하기 때문에 예상하는 최적의 결과를 얻을 수 있음
  - 경으의 수가 많을 경우 시간이 오래걸
- 비트마스크
  - 모든 경우의 수를 이진수로 표현하고 비트 연산을 통해 원하는 결과를 빠르게 얻을 수 있는 알고리즘
  - 이진수 연산을 이용하여 계산 속도가 빠름
  - 경우의 수가 많아지면 메모리 사용량이 증가하게 됨
- 재귀함수
  - 자기 자신을 호출하여 가능한 모든 경우의 수를 탐색 후 최적의 해답을 얻는 방식
  - 코드가 간결하고 이해하기 쉽다는 장점
  - 재귀호출이 많아지면 스택 오버플로우가 발생할 수 있음
- 백트래킹
  - 가지치기를 통해 완전탐색을 개선한 방식
  - 탐색해야하는 경우의 수를 줄이며 모든 경우를 탐색할 수 있음
  - 재귀 호출을 활용하기 때문에 마찬가지로 스택 오버플로우가 발생할 수 있음
- 순열
  - 서로 다른 n개 중 r개를 선택하여 나열하는 방법
  - 경우의 수가 적을때 사용하기 유용함
  - 경우의 수가 많다면 오래걸림
- dfs/bfs
  - 한 노드의 가장 마지막 자식 노드까지 탐색하고 다시 분기점으로 돌아오는 dfs와 한 노드의 인접한 노드를 먼저 탐색하는 bfs
  - 최악의 경우, 모든 노드를 다 방문해야 함

### 시간복잡도
| 알고리즘 종류 | 시간복잡도 |
|---------------|-------------|
| Brute Force   | O(n × m)    |
| 비트마스크    | O(2ⁿ × n)   |
| 재귀함수      | O(n)        | 
| 백트래킹      | 최악 O(n!)       | 
| 순열          | O(n!)       | 
| DFS / BFS     | O(V + E)    | 


### 예시
```java
//자물쇠의 3자리 비밀번호 찾기
//반복문과 조건문으로 해결, 일반적인 브루트포스
public class example {

    static int [] password = {3,4,5};

    public static void main(String[] args) {

        for(int i = 0 ; i < 10 ; i ++){
            for(int j = 0 ; j < 10 ; j ++){
                for(int k = 0 ; k < 10 ; k ++){

                    if(password[0] == i && password[1] == j && password[2] == k){

                        System.out.println("자물쇠 해제 ");
                        System.out.println("비밀번호는 " + i + j + k);
                        break;
                    }

                }
            }
        }
    }
}
```

## 그리디
### 그리디란?
- 최적의 값을 구해야 하는 상황에서 각 단계에서 최적의 선택을 해 나가는 방식으로 해답에 도달하는 알고리즘
- 항상 최적의 값을 보장하는 것이 아닌 최적의 값의 근사하는 값을 목표로 

### 그리디 주요 개념
- 문제에서 다음 두 가지 조건을 만족해야 그리디 적용이 가능
  1. 탐욕 선택 : 현재 단계에서 가장 이득이 되는 것을 선택하고 그 선택이 전체에 대한 최적해를 구할 수 있는 경우
  2. 최적 부분 구조 : 전체 문제의 최적해가 부분 문제의 최적해로 구성되어야 함
 
### 그리디 알고리즘 단계
- 선택 절차 : 현재 상태에서 최적의 선택을 함
- 적절성 검사 : 선택 항목이 문제의 조건에 부합여부를 판단
- 해답 검사 : 모든 선택이 완료된 후 최종 선택이 문제의 조건에 부합하는지 판단

### 그리디 알고리즘 예
- 거스름돈 문제
```java
public class ChangeCalculator {
    public static void main(String[] args) {
        int[] coins = {500, 100, 50, 10}; // 사용 가능한 동전 단위 (큰 순서)
        int amount = 1260; // 거슬러 줄 총 금액
        int count = 0;     // 사용한 동전 개수

        // 선택 절차 + 적절성 검사
        for (int coin : coins) {
            if (amount >= coin) { // 현재 금액보다 동전이 작거나 같은 경우에만 선택
                int num = amount / coin; // 해당 동전 몇 개 쓸 수 있는지 계산
                count += num; // 총 동전 개수에 더함
                amount -= coin * num; // 남은 금액에서 해당 동전만큼 차감
            }
        }

        // 해답 검사
        if (amount == 0) {
            System.out.println("총 동전 개수: " + count); // 최종 결과 출력
        } else {
            System.out.println("정확하게 거슬러 줄 수 없습니다.");
        }
    }
}
```
