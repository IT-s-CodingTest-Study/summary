## DP
### DP란?
- 복잡한 문제를 여러 개의 작은 하위 문제로 분할하여 하위 문제의 해답을 저장하고, 이를 재활용하며 전체 문제의 해답을 효율적으로 구하는 기법
- 중복되는 하위 문제의 해답을 저장하고 해당 값을 재사용 함으로써 효율적인 설계가 가능
### DP의 핵심 조건
- 부분 문제 반복
  - 동일한 하위 문제가 여러 번 반복되어 등장해야함
  - ex) 피보나치 수열에서 fib(2)를 여러번 계산하게 됨
- 최적 부분 구조
  - 작은 문제들의 최적해를 활용하여 큰 문제의 최적해를 구해야 함
  - 부분 문제의 해답이 전체 문제의 해답을 구성

>```java
> public int fibonacci(int n) {
>    if(n <= 1) return n;
>    return fibonacci(n - 1) + fibonacci(n - 2);
>}
>
>//재귀호출을 통해 fibonacci(2)는 여러번 호출하여 계산됨
>```
>

### DP의 동작 절차
- 문제를 하위 문제로 분할
- 하위 문제를 해결
- 결과를 저장(메모제이션 or 테이블화)
  - 이미 계산한 하위 문제의 결과를 저장
  - 동일한 하위 문제가 등장하게 된다면 저장된 값을 재사용
- 문제 해결
  - 전체 문제의 해답을 구하여 해결

> 메모제이션(Memoization)
> > - 함수의 결과값을 저장해 두었다가 동일한 입력이 있다면 저장되어있는 값을 반환하여 중복 계산을 피하는 기법
> > - 주로 재귀 방식에서 사용하며, 호출한 하위 문제가 캐시(배열, 맵)에 저장된 결과가 있다면 그 결과를 반환
> > - 필요한 하위 문제만 계산할 수 있다는 장점
> > - 많은 재귀호출로 인해 스택오버플로우의 위험이 있음

> 테이블화(Tabulation)
> > - 하위 문제부터 차례로 해결하며 그 결과를 테이블(배열)에 저장하여 큰 문제의 해답을 구하는 방식
> > - 반복문을 통해 구현하며 작은 문제부터 값을 테이블에 채워나고 중복된 하위 문제가 있다면 저장된 값을 반환
> > - 하위 문제를 모두 계산
> > - 메모리 사용량은 많을 수 있으나 스택을 사용하지 않기 때문에 스택오버플로우 위험은 없음

### DP 구현 방식
- Bottom-up 방식(테이블화)
```java
public static int fibonacci(int n) {
    int[] fib = new int[n + 1];
    fib[0] = 0;
    fib[1] = 1;
    for (int i = 2; i <= n; i++) {
        fib[i] = fib[i - 1] + fib[i - 2];
    }
    return fib[n];
}
```
- Top-down 방식(메모제이션)
```java
private int[] memo;
public int fibonacci(int n) {
    if (n == 0) return 0;
    if (n == 1) return 1;
    if (memo[n] != -1) return memo[n];
    memo[n] = fibonacci(n - 1) + fibonacci(n - 2);
    return memo[n];
}
```
Bottom-up 과 Top-down 방식의 비교
| 구분            | Bottom-up 방식 (반복문 + 테이블화)                         | Top-down 방식 (재귀 + 메모이제이션)   |
|-----------------|-----------------------------------------------|-----------------------------------------|
| 구현 방법       | 반복문으로 작은 문제부터 차례로 해결              | 재귀 호출로 큰 문제를 작은 문제로 분할    |
| 호출 흐름       | 작은 문제 → 큰 문제 (순차적)                     | 큰 문제 → 작은 문제 (필요할 때만 호출)    |
| 초기값          | 테이블의 base case를 명시적으로 초기화            | base case를 재귀 조건에서 처리            |
| 스택 사용       | 별도의 재귀 호출 스택 없음                       | 재귀 호출로 인해 콜스택 사용              |
| 성능            | O(n), 스택 오버플로우 위험 없음                  | O(n), 스택 오버플로우 위험(입력값이 클 때)|
| 가독성          | 코드가 직관적, 순차적 흐름                        | 수학적 정의와 유사, 이해하기 쉬움         |
| 적합 상황       | 입력 크기가 크거나 하위 문제를 모두 계산해야 할 때  | 일부 하위 문제만 필요할 때(가지치기 가능) |

### DP 구현의 장점
- 반복인 하위 문제를 재활용 하여 계산 시간을 단축
- 항상 최적해를 찾을 수 있음
- 다양한 문제에 적용이 가능
