## 트리


💡  계층적인 구조를 표현하는 비선형 자료구조로, 노드(Node)와 간선(Edge)로 구성 

### 📌 특징

- 순환 없음 (비순환 그래프)  - 어떤 노드에서 시작해도 다시 자신에게 돌아올 수 없음
- N개의 노드 → 항상 N-1개의 간선
- 계층 구조 표현에 적합 (예: 폴더 구조, 조직도 등)

## 구성요소

- **루트(Root)** : 트리의 최상단 노드 (유일)
- **부모(Parent)** : 현재 노드를 직접 연결한 상위 노드
- **자식(Child)** : 현재 노드에 연결된 하위 노드
- **형제(Sibling)** : 같은 부모를 공유하는 노드들
- **리프(Leaf)** : 자식이 없는 노드 (말단 노드)
- **서브트리(Subtree)** : 특정 노드와 그 하위 노드로 구성된 트리
- **차수(Degree)** : 한 노드가 가지는 자식의 수
- **트리의 높이(Height)** : 루트에서 리프까지의 최대 거리
- **노드의 깊이(Depth)** : 루트에서 해당 노드까지 도달하는 데 거치는 간선 수

## 이진 트리 (Binary Tree)

💡 모든 노드가 최대 2개의 자식 노드를 가지는 트리 구조

![이진트리](https://github.com/IT-s-CodingTest-Study/summary/blob/main/%ED%95%98%EB%82%98/4%EC%A3%BC%EC%B0%A8/%ED%99%94%EB%A9%B4%20%EC%BA%A1%EC%B2%98%202025-04-23%20215821.png)



- 구성: 루트 노드 + 왼쪽 서브트리 + 오른쪽 서브트리

- 자식이 2개 이하이기 때문에 배열을 이용한 구현이 용이함 (특히 완전/포화 트리일 때)

### 완전 이진 트리

- 마지막 레벨을 제외하고 모두 채워져 있음
- 마지막 레벨의 노드는 왼쪽부터 차례로 채워짐
- 힙 구조에서 자주 사용됨

### 포화 이진 트리

- 모든 레벨이 노드로 가득 찬 트리
- 노드 수 =  2ⁿ - 1 (n은 트리의 높이)

### 편향 이진 트리

- 모든 노드가 한쪽 자식만 갖는 트리(좌/우 한쪽으로 치우침)
- 최악의 경우 연결 리스트와 같음 → 시간복잡도 증가

### 이진 트리 순회

💡 트리 구조를 순서대로 탐색하는 방법  

1. 전위 순회 
    
    → 구조 출력 등 트리 복사에 적합
    
    ```
    NLR (Node, Left, Right) : 루트-왼쪽-오른쪽
    ```
    
2. 중위 순회
    
    → 이진 탐색 트리에서 오름차순 효과
    
    ```
    LNR (Left, Node, Right) : 왼쪽-루트-오른쪽
    ```
    
3. 후위 순회
    
    → 삭제/정리 작업에 적합(자식부터 삭제)
    
    ```
    LRN (Left, Right, Node) : 왼쪽-오른쪽-루트
    ```
    
4. 레벨 순회
    
    → 레벨 단위로 순회, 최단 거리 탐색 등에 활용
    
    ```
    BFS (Breadth-First Search) 
    ```
    

## 힙 Heap

💡 최솟값 또는 최댓값을 빠르게 찾아내기 위한 완전 이진 트리 기반의 자료구조

→ 우선순위 큐(Priority Queue) 구현 시 많이 사용됨

### 📌 특징

- **완전 이진 트리** 구조 → 배열로 쉽게 구현 가능
- **부모-자식 간의 대소 관계만 유지**, **형제 노드 간의 관계는 무관**
- 루트 노드에서 항상 최대/최소 값을 빠르게 접근할 수 있음
- 삽입/삭제 연산 시 재정렬을 통해 힙 속성을 유지

### 최대 힙 - Max Heap

💡 부모  노드의 키값  ≥ 자식 노드의 키값

- 루트 노드에는 항상 최댓값이 위치
- 값이 큰 요소를 우선 처리할 때 유용

### 최소 힙 - Min Heap

💡 부모 노드의 키값 ≤ 자식 노드의 키값

- 루트 노드에는 항상 최솟값이 위치
- 값이 작은 요소를 우선 처리할 때 유용 (다익스트라 등)

### 힙 정렬

1. 주어진 배열을 힙으로 변환
2. 루트(최댓값)를 꺼내어 배열의 끝에 삽입
3. 남은 힙에 대해 재정렬 반복

→ 불안정 정렬(같은 값의 순서 보장 x), 비교 기반 정렬

### 힙의 구현 (배열 기반)

- 인덱스 i의 노드에 대해
    - 왼쪽 자식 = 2 * i
    - 오른쪽 자식 = 2 * i + 1
    - 부모 = i / 2

→ java에서는 우선순위 큐를 통해 MinHeap 기본 제공

`Max Heap`은 `PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());` 로 구현

### 힙 사용 예시

- 우선 순위 큐
- k번째 최소/최댓값 찾기
- 힙 정렬
- 다익스트라 알고리즘 (최단경로)
- Top-K 문제 (가장 많이 등장한 요소 등등)
