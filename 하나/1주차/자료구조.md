# 스택 (Stack)

💡 **후입선출 (LIFO: Last-In, First-Out)** 방식의 선형 자료구조  
> 가장 마지막에 들어간 데이터가 가장 먼저 나오는 구조

데이터를 차곡차곡 **쌓는** 방식으로, 책을 쌓거나 접시를 쌓는 모습과 비슷하다.  
나중에 넣은 것이 먼저 나온다.

## ✅ 주요 연산
- `push(n)` : 요소 `n`을 스택의 맨 위에 추가
- `pop()` : 맨 위 요소를 제거하고 반환
- `peek()` : 맨 위 요소를 제거하지 않고 반환
- `isEmpty()` : 스택이 비었는지 확인 (True/False)
- `isFull()` : 스택이 가득 찼는지 확인 (일반 배열 기반에서만 사용)
- `size()` : 스택의 전체 요소 수
<br/>  
  이미지---  
> ❗ **스택 오버플로우**: 스택이 꽉 찼는데 `push()`를 시도하는 경우 오류가 발생한다.
 
## 📌 스택 활용 예시

-  **재귀 함수 처리** 
-  **웹 브라우저 방문 기록** (뒤로 가기/앞으로 가기)
- **텍스트 편집기 실행 취소** 

## ✅ 장단점

- 장점: 구현이 단순하고, 빠른 삽입/삭제 연산 가능 (O(1))
- 단점: 크기 제한이 있는 경우 메모리 부족 문제 가능

---

# 큐 (Queue)

 💡 **선입선출 (FIFO: First-In, First-Out)** 구조의 선형 자료구조  
> 먼저 들어온 데이터가 먼저 나가는 구조

은행 대기줄이나 인쇄 대기열처럼 **줄을 서는 구조**로 동작한다.  
뒤(`rear`)에서 삽입하고, 앞(`front`)에서 제거한다.

  이미지---  

## ✅ 주요 연산  
- `enqueue(n)` : 요소 `n`을 큐의 뒤쪽에 추가
- `dequeue()` : 큐의 앞쪽 요소를 제거하고 반환
- `peek()` : 가장 앞쪽 요소를 반환
- `isEmpty()` : 큐가 비었는지 확인
- `isFull()` : 큐가 가득 찼는지 확인
- `size()` : 큐의 전체 요소 수

## 📌 큐 활용 예시

-  **프로세스 스케줄링**
-  **은행 업무 번호표 시스템**
-  **그래프 너비 우선 탐색 (BFS)**

<br/>  

### tmi  
Java에서의 큐 삽입 메서드: `add()` vs `offer()` 비교

| 메서드 | 큐가 꽉 찼을 때 | 반환값 |
|--------|------------------|--------|
| `add(e)` | 예외 발생 (`IllegalStateException`) | 없음 |
| `offer(e)` | false 반환 (예외 없음) | `true` or `false` |

> ✅ `offer()`는 예외를 던지지 않으므로, 안정성이 필요한 상황에 적합

---

# 원형 큐 (Circular Queue)

> 💡 끝과 시작이 연결된 구조

- 배열의 시작과 끝을 연결해 **공간을 낭비 없이 사용**
- 삽입/삭제 시 **모듈로 연산 (`%`)**을 사용해 인덱스를 순환시킴

 원형 큐는 일반 큐의 단점을 보완한 구조  
 - 큐가 꽉 찬 것처럼 보여도 사실은 비어있는 공간이 있을 수 있어서 이를 활용함  
 - 일반적인 큐에서는 `dequeue()`로 요소를 앞에서 제거하면, 앞쪽 공간이 비어 있음에도 불구하고 새로운 데이터를 삽입하지 못함

---

# Deque (Double-ended Queue)

> 💡 **양쪽 끝**에서 삽입과 삭제가 가능한 자료구조

**스택과 큐의 장점을 결합**한 구조. `덱(Deque)` 또는 `디큐`라고도 부른다.

## ✅ 주요 특징

- 앞(front)에서도 삽입/삭제 가능
- 뒤(rear)에서도 삽입/삭제 가능
- 내부는 **양방향 연결 리스트**로 구현되는 경우가 많음

✅ 주요 메서드
- addFirst(n) : 앞쪽에 요소 추가
- addLast(n) : 뒤쪽에 요소 추가
- removeFirst() : 앞쪽 요소 삭제
- removeLast() : 뒤쪽 요소 삭제
- peekFirst() : 앞쪽 요소 조회
- peekLast() : 뒤쪽 요소 조회
---
