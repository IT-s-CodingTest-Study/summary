## **동적 계획법 Dynamic Programming**

→ 이미 계산된 결과는 별도의 메모리 영역에 저장하여 다시 계산하지 않도록 설계함으로 수행 시간 효율성을 향상시키는 기법이다.

*DP 구현 방법은 일반적으로 두 가지 방식, Top-down(하향식)과 Bottom-up(상향식)으로 구성  

---   
## 동적 계획법의 구현 단계

1. 문제를 하위 문제로 쪼갬
2. 하위 문제를 재귀적으로 해결
3. 결과를 저장 (메모이제이션)
4. 저장된 결과를 이용하여 큰 문제를 해결

      (* 해당 단계를 통해서 중복 계산을 피하여 성능을 높임)
--- 
## Top-Down

- 문제를 큰 문제에서 작은 문제로 분할하며 해결
- 계산 결과를 저장해두는 배열을 활용
- 재귀 호출 + 메모이제이션
- Java에서는 보통 배열을 -1로 초기화하여 메모 배열로 사용

```java
int[] memo;

public int topDown(int n) {
    if (n <= 1) return n;
    if (memo[n] != -1) return memo[n];
    return memo[n] = topDown(n - 1) + topDown(n - 2);
}
```

## Bottom-up

- 작은 문제부터 차례대로 계산하여 전체 문제를 해결
- 점화식을 기반으로 반복문을 통해 채워 나감

```java
public int bottomUp(int n) {
    int[] dp = new int[n + 1];
    dp[0] = 0;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```

## Top-down vs Bottom-up 비교
| 항목     | Top-down                    | Bottom-up      |
| ------ | --------------------------- | -------------- |
| 구현 방식  | 재귀 + 메모이제이션                 | 반복문 + 배열       |
| 성능     | 재귀 호출 많으면 느릴 수 있음           | 일반적으로 빠르고 안정적  |
| 코드 가독성 | 간결하고 직관적                    | 약간 복잡할 수 있음    |
| 메모리 효율 | 호출 스택 사용 → StackOverflow 위험 | 메모리 사용 예측 가능   |
| 추천 상황  | 단순하거나 작고 직관적인 문제            | 대규모 입력, 실무용 문제 |
