# 동적 계획법 (Dynamic Programming, DP)

## 동적 계획법이란?

- **복잡한 문제를 작은 부분 문제로 나누어 푸는 알고리즘 기법**
- 이미 계산한 결과를 저장하여 **중복 계산을 방지**한다.
- 시간 복잡도는 O(N) 또는 O(N²)이며, 브루트포스보다 효율적이다.

---

## 사용 조건

- **최적 부분 구조**: 큰 문제의 해답이 작은 문제의 해답으로 구성됨
- **중복 부분 문제**: 동일한 하위 문제를 반복해서 계산하게 됨

---

## 기본 구조

### 1. Top-down

- 재귀함수로 하향식 해결
- `dp` 배열을 사용해 중복 호출 방지

```java
int fib(int n) {
    if (n <= 1) return n;
    if (dp[n] != 0) return dp[n];
    return dp[n] = fib(n - 1) + fib(n - 2);
}
```

### 2. Bottom-up

- 작은 문제부터 `dp` 배열을 채우는 방식

```java
dp[0] = 0;
dp[1] = 1;
for (int i = 2; i <= n; i++) {
    dp[i] = dp[i - 1] + dp[i - 2];
}
```

---

## 문제 유형

| 문제 유형            | 예시 문제           | 목표                         | dp 배열 의미            |
|---------------------|---------------------|------------------------------|--------------------------|
| 피보나치 수열       | 피보나치            | n번째 수 구하기              | i번째 피보나치 수       |
| 계단 오르기         | 계단 오르기         | 도달 가능한 최대 점수       | i번째 계단까지의 최대합 |
| 정수 삼각형         | 정수 삼각형         | 최댓값 경로 구하기           | 해당 위치까지의 누적합  |
| 집 도둑 문제        | 도둑질              | 첫 집과 마지막 집을 동시에 털 수 없음 | i번째 집까지의 최댓값   |
| 동전 교환 문제      | 최소 동전 개수 구하기 | 특정 금액 만들기           | 금액별 최소 동전 수     |
| 배낭 문제 (Knapsack) | 무게 제한 최댓값    | 제한된 무게로 최대 가치 얻기 | 무게별 최대 가치        |

---

## 실전 문제에 적용

- 문제 조건이 "최댓값", "최솟값", "경우의 수" 등으로 주어질 때 DP 여부를 판단
- dp 배열의 정의(무엇을 저장할지)를 명확히 하는 것이 핵심임
- 점화식(이전 상태로부터 현재 상태를 계산하는 식)을 도출할 수 있어야 함
- 반복되는 계산을 줄이기 위해 memoization 또는 table을 사용

---

## 자주 나오는 실수

- dp 배열의 초기값 설정 오류
- 배열 인덱스 초과 및 범위 예외 처리 미흡
- Top-down 방식에서 memo 배열 누락
- 문제에서 요구하는 결과값과 dp 배열에서 사용하는 값이 일치하지 않음
