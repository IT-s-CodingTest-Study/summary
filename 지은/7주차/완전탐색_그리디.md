# 완전 탐색 (Brute-force)

### 개념

- 가능한 **모든 경우의 수**를 전부 탐색해서 정답을 찾는 방법
- 정답은 **반드시 존재** (정답 보장)
- 하지만 경우의 수가 많아지면 **시간 복잡도가 급격히 증가**함 → 비효율적

### 종류

- **브루트 포스(Brute Force)**
    - 반복문과 조건문을 사용하여 가능한 모든 조합을 전부 시도해보는 가장 기본적인 방법 
    `(예: 모든 비밀번호 조합 탐색)`
- **순열 (Permutation)**
    - 순서를 고려한 나열
     `(예: 자리 배치, 숫자 조합)`
- **재귀 함수 (Recursion)**
    - 함수가 자기 자신을 호출하며 상태를 누적 
    `(예: 수열 생성, 트리 탐색)`
- **DFS / BFS**
    - 그래프 또는 트리 기반 상태 공간 깊이/너비 우선 탐색 
    `(예: 미로 탈출, 연결 요소 개수)`
- **백트래킹 (Backtracking)**
    - 탐색 중 이 경로가 가능성이 없다고 판단되면 즉시 되돌아가는 가지치기 기법
    - 반복문의 횟수를 줄일 수 있어 효율적이지만 최악의 경우에는 여전히 완전 탐색에 해당
- **비트마스크 (Bit Mask)**
    - 선택 여부를 비트(0,1)로 표현해 상태를 관리하는 방식  
     `(예: 방문 여부 체크, 부분 집합의 합)`
    - 선택/비선택처럼 두 가지 상태를 표현할 수 있어서 유용함

### 장점과 단점

| 장점 | 단점 |
| --- | --- |
| 정답 보장됨 | 비효율적 (시간복잡도 큼) |
| 간단한 문제는 쉽게 구현 가능 | 입력이 크면 시간 초과 발생 |

### 주의점 / Tip

- 경우의 수 계산 먼저!
    
    ex) `순열 n! → n = 10 이면 3,628,800`  → 시간 제한 고려 필요
    
- `visited[]`, `DFS 깊이 제한`, `가지치기`로 불필요한 탐색 줄이기
- 입력이 작고, “모든 경우의 수”가 언급되면 완전탐색 문제일 가능성 높음’

---

# 그리디 (Greedy)

### 개념

- 매 순간 가장 좋아 보이는 선택을 하며 최적해를 구하는 알고리즘
- 정답을 항상 보장하진 않음
- 단, 특정 조건을 만족할 때는 빠르고 정확하게 해결 가능

> **적용 조건**
> 
> - **탐욕적 선택 속성**
>     - 현재의 선택이 이후의 선택에 영향을 주지 않아야 함
>     - 매 순간 최선의 선택이 전체 최적해로 이어져야 함
> - **최적 부분 구조**
>     - 부분 문제의 최적해를 모아 전체 문제의 최적해를 구성할 수 있어야 함

→ 그리디는 **지역 최적 = 전역 최적**이 성립하는 문제에서만 사용 가능

### 종류

- **정렬 기반 선택:** 종료 시간, 이익, 비용 등 기준을 정해 정렬 후 선택
    
    `(예: 거스름돈 문제, 회의실 배정)`
    
- **우선순위 큐 사용:** 높은 우선순위를 빠르게 선택
    
    `(예: 작업 스케줄링, 다익스트라)`
    

### 장점과 단점

| 장점 | 단점 |
| --- | --- |
| 빠르고 효율적 (보통 O(n log n)) | 정답 보장 X (문제 조건 따라 달라짐) |
| 구현 간단하고 깔끔 | 그리디 조건 안 맞으면 오답 발생 |

### 예시 - 거스름돈 문제

**문제 설명**

- 손님이 1000엔을 지불하고, 물건 가격은 X엔이다.
- 거슬러야 할 금액을 가장 적은 동전의 개수로 계산하라.

```java
public class BOJ5585 {
    public static void main(String[] args) {
        int pay = 1000 - 380; // 380엔 물건 구매 후 거스름돈
        int[] coins = {500, 100, 50, 10, 5, 1};
        int count = 0;

        for (int coin : coins) {
            count += pay / coin;
            pay %= coin;
        }

        System.out.println(count); // 출력: 최소 동전 개수
    }
}
```

> **왜 그리디 알고리즘인가?**
> 
> - 탐욕적 선택 속성
>     - 가장 큰 동전부터 최대한 많이 사용
>     - 현재 선택이 이후 선택에 영향을 주지 않음 → 지역 최적 선택이 전체 최적으로 이어진다.
> - **최적 부분 구조**
>     - 일부 금액을 해결한 후, 남은 금액도 동일한 방식으로 해결 가능

> **이 문제에서 그리디가 정답을 보장하는 이유**
> 
> - 동전 단위가 서로 배수 관계이기 때문에
> - 항상 큰 단위부터 선택하면 최소 개수의 동전으로 거슬러 줄 수 있음

**반례 - 그리디가 실패하는 경우**

동전 단위 : `{ 10, 6, 1 }`

목표 금액 : `12`

- 그리디 선택: 10 + 1 + 1 = 3개
- 최적 선택: 6 + 6 = 2개

→ 이처럼 **동전 단위가 배수 관계가 아닐 경우**,

→ 그리디는 항상 정답을 보장하지 않는다.


### 주의점 / Tip

- 문제에서 지역 최적 = 전체 최적해가 성립하는지 먼저 확인해야 함
- “최소 / 최대” 와 “조건을 만족하는 경우” 라는 문장이 함께 등장하면 그리디 의심
- 그리디는 최적값만 구하지, 경우의 수를 따지지 못 함
    - 경우의 수, 모든 경로 출력 등 대부분 그리디가 아님
    - 그리디는 하나의 해를 구하는 데 특화되어 있는 편
