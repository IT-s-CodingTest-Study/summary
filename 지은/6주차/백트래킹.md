## 백트래킹(Backtracking)

**“가능성이 없는 경로는 더 이상 탐색하지 않는다.”** 

→ 모든 경우를 재귀적으로 탐색하면서, **불필요한 경로는 조기에 차단**하는 방식


### 핵심 개념

1. **DFS 기반 탐색**
    
    깊이 우선 탐색처럼 작동하되, 해답이 될 수 없는 경로는 즉시 중단하고, 이전 상태로 되돌아간다.
    
2. **유망성 판단과 가지치기(Pruning)**
    
    현재 경로가 해가 될 가능성이 있는지 판단하고, 아니라면 더 이상 탐색하지 않는다.
    
3. **상태 공간 트리 검색**
    
    재귀 호출 안에서 유망성 조건을 검사하고, 조건을 만족하는 경우에만 다음 노드로 진행한다.
    


### 가지치기(Pruning)

- **의미**: 해가 될 수 없는 경로는 미리 탐색하지 않고 제거
- **목적**: 탐색 공간을 줄이고, 불필요한 연산을 방지
- **중요성**: pruning 조건 설정이 성능에 결정적 영향
(예: 합이 초과하는 경우, 중복 선택 등)

---

### **언제 사용해야할까?**

- 완전 탐색이 필요한 경우
- 순열 또는 조합과 관련된 경우
- 결정 문제 (선택 or 제외, 1 or 0)
- N_Queen 문제
- 스도쿠, 단어 퍼즐 탐색


### 백트래킹 vs. DFS

| 구분 | 백트래킹 | DFS |
| --- | --- | --- |
| 탐색 방식 | 가능성이 없으면 중간에 중단 | 모든 경로를 끝까지 탐색 |
| 목적 | 해 탐색 + 최적화 | 전체 구조 순회, 경로 탐색 |
| 가지치기 | 있음 (Pruning) | 없음 |
| 성능 | 효율적(탐색 공간 줄임) | 비효율적(모든 경로 탐색) |


### 동작 방식

- **결정(decision) → 검증(validation) → 백트래킹(backtrack)**
- 어떤 선택을 하고 → 유효한지 검사하고 → 아니라면 원래 상태로 돌아가 다음 선택을 시도

  →  이 과정을 재귀적으로 반복하며 해를 찾음 

### 기본 구조

```java
void backtrack(상태) {
    // 1. 종료 조건: 더 이상 탐색이 불필요할 때 종료
    if (정답이면) return;

    // 2. 가능한 선택지들을 반복하며 탐색
    for (선택 가능한 경우의 수) {

        // 3. 현재 조건이 유망한가?
        if (유망성 조건 만족) {

            // 4. 선택: 현재 경로에 이 선택을 반영하여 상태를 업데이트
            선택;

            // 5. 더 깊이 탐색 (재귀 호출)
            backtrack(업데이트);

            // 6. 선택 취소 (Backtracking): 재귀 호출이 끝난 뒤, 이전 상태로 복구
            선택 취소;
        }
    }
}
```


### 장점

- **효율적인 탐색**
    
    불필요한 경로를 조기에 차단함으로써 탐색 공간을 효과적으로 줄일 수 있다.
    
    전체 경우를 모두 탐색하는 것보다 훨씬 빠르며, **가지치기 조건**을 잘 설정할수록 성능이 크게 향상된다.
    

### 단점

- **조건 설계가 까다로움**
    
    가지치기 조건을 제대로 설정하지 않으면 모든 경로를 탐색하게 될 수 있다.
    
    (ex: 대부분의 경로가 유망해 pruning 효과가 거의 없을 때)
    
- **재귀 깊이에 따른 스택 오버플로우**
    
    탐색 깊이가 깊어지면 스택 오버플로우가 발생할 수 있다.
    

---

### 추가) 중복 탐색 방지: visited[ ]와 메모이제이션

백트래킹은 중복 상태를 따로 저장하지 않으면, 같은 상태를 여러 경로로 다시 탐색할 수 있다.

이 때 필요한 것이 중복 방지 방법인데 두 가지 방법이 있다. 

- **visited 배열**
    
    현재 탐색 경로 내에서 같은 원소나 노드를 중복 선택하지 않도록 막는다.
    
    (예: 순열 문제에서 이미 사용한 숫자 재선택 방지)
    
- **메모이제이션**
    
    같은 상태(예: 인덱스, 누적합 등)의 계산 결과를 저장해, 전체 탐색 중 중복 계산을 피하는 기법
    

**→ visited는 경로 내 중복을, 메모이제이션은 전체 탐색 중 계산 중복을 막는다.**
