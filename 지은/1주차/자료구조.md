## 1. 스택(Stack)

<img src="https://github.com/user-attachments/assets/70558250-2397-4473-b181-e7514f376360" width="400">

**<특징>**

- **후입선출(LIFO:  Last-In First-Out) 구조** : 마지막에 넣은 요소가 제일 먼저 나온다.
- 항상 맨 위(top) 요소에서 연산이 이루어진다.
- 데이터가 없을 때 pop 하면 오류 : stack underflow
- 용량을 초과해 push 하면 오류: stack overflow

**<연산>**

1. `push(값)` : 스택에 요소 값 삽입
2. `pop()` : 맨 위 요소 꺼내고 제거
3. `peek()` : 맨 위 요소 조회(제거 X)
4. `isEmpty()` : 스택이 비었는지 확인
5. `size()` : 스택의 전체 요소 수

**<시간복잡도>**

- 삽입/삭제: O(1)
- top 요소 조회 : O(1)
- 탐색
    - 탐색은 stack의 구조 상 비효율적이며 보통 사용하지 않는다. 굳이 한다면 O(n)

**<장점>**

- 데이터의 삽입/삭제 연산이 빠름: push, pop 모두 O(1) → 스택의 맨 위에서 처리하기 때문
- 역추적하기 좋은 구조

**<단점>**

- 탐색(접근)이 어려움: 탐색을 하려면 요소를 하나씩 pop 해야 함.
- 중간 데이터를 삽입, 삭제, 탐색해야 할 경우, 매우 비효율적
 
**<언제 사용할까>**

- 최근 데이터 조회: 브라우저 ‘뒤로 가기’, 명령 ’실행 취소’
- 순서 반전이 필요한 조건: 문자열 역순
- 재귀 함수, 괄호  검사, DFS (깊이 우선 탐색)

---

## 2. 큐 (Queue)

<img src="https://github.com/user-attachments/assets/606060bf-22bf-4972-a924-7379c57a5098" width="400"/>

**<특징>**

- 선입선출(FIFO: First-In First-Out) 구조: 먼저 넣은 데이터가 먼저 나온다.
- queue의 사전적 정의는 **줄을 서서 기다리는 ‘대기줄’ → 실제 동작도 선입선출**
- 입력과 출력이 다른 방향에서 이루어짐
    - rear에서 삽입(Enqueue)
    - front에서 삭제(Dequeue)

**<연산>**

1. `offer(값)` : 맨 뒤(rear)에 데이터 삽입 (Enqueue)
2. `poll()` : 맨 앞(front) 요소 제거 (Dequeue)
3. `peek()` :  맨 앞 요소 조회 (제거X)
4. `isEmpty()` : 큐가 비었는지 확인
5. `size()` : 큐에 들어 있는 요소 개수

**<시간복잡도>**

- 원소를 삽입/삭제하는 경우: O(1)
- 탐색은 queue의 구조 상 비효율적이며 보통 사용하지 않는다. → O(n)

**<장점>**

- 데이터의 삽입/삭제가 빠르다.
- 입력된 순서를 유지해야할 때 가장 적합한 구조이다.

**<단점>**

- queue 중간에 위치한 데이터의 접근이 어렵다.
- 우선순위가 없는 구조라 중요도 반영이 어렵다.

**<언제 사용할까>**

- 입력 순서를 유지하는 것이 중요할 때
- 너비 우선 탐색(BFS)
- 프린터 큐, 고객 상담 시스템

### 추가) 우선순위 큐 (Priority Queue)

- 이름은 큐지만, 실제 동작은 힙 연산 기반
- 우선순위가 높은 요소가 먼저 처리된다.
    - ex)  응급실 환자 → 먼저 온 순서보다 **위급도(우선순위)**가 더 중요
- 자바에서는 `PriorityQueue` 클래스를 사용하며, 
기본적으로 오름차순 정렬(Min Heap) 기반이다.

---

## 3. 덱 (Deque)

<img src="https://github.com/user-attachments/assets/8288cf39-eb5d-423a-9583-718191357f87" width="400"/>

**<특징>**

- 스택과 큐의 기능을 모두 포함하는 유연한 구조
- Deque는 **Double-Ended Queue**의 줄임말
- queue와 다르게 front와 back에서 삭제/삽입이 모두 가능하다.

**<연산>**

- `offerFirst(x)` : 앞(front)에 요소 추가
- `offerLast(x)` : 뒤(rear)에 요소 추가
- `pollFirst()` : 앞 요소 제거 후 반환
- `pollLast()` : 뒤 요소 제거 후 반환
- `peekFirst()`, `peekLast()` : 앞/뒤 요소 조회 (제거 X)

**<시간복잡도>**

- 대부분의 연산(앞/뒤 삽입, 삭제) : O(1)
- 중간 탐색/접근은  매우 비효율적

**<장점>**

- 스택, 큐 모두 구현 가능
- 앞/뒤 양방향으로 삽입/삭제 가능
- 메모리 공간 활용이 유연함 (ArrayDeque는 크기 자동 조절)

**<단점>**

- 최소 메모리 공간이 큼: 하나의 원소만 가진 dequeue도 큰 메모리 공간을 차지
- 중간 삽입/삭제가 어렵다.

**<언제 사용할까>**

- 양 끝 삽입/삭제가 자주 발생하는 경우
- 슬라이딩 윈도우, 회전 큐, 카드 뽑기
