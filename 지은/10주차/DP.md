## 동적계획법(DP) 개념 정리

### 1. 개념

- 큰 문제를 작은 문제로 나누어 푸는 방식
- 동일한 하위 문제가 반복될 경우, 계산 결과를 저장해 중복 계산을 피함
- 탐색 + 메모이제이션 형태

---

### 2. 적용 조건

- **중복되는 부분 문제(Overlapping Subproblems)**
    
    동일한 하위 문제가 반복적으로 호출될 때
    
- **최적 부분 구조(Optimal Substructure)**
    
    상위 문제의 최적해가 하위 문제의 최적해로 구성될 때
    

ex) 피보나치 수열은 위 조건을 만족하므로 DP 적용 가능

---

### 3. 점화식

- 현재 문제를 이전 상태로 표현한 수식
- `dp[i] = dp[i - 1] + dp[i - 2]` 형태처럼, **이전 결과를 이용해 현재 값을 계산**함
- 문제의 핵심 규칙이므로 점화식을 정확히 세우는게 DP에서 가장 중요

---

## 구현 방식

### 1. Top-down 방식 (하향식)

- 재귀 호출을 통해 상위 문제를 해결
- 이미 푼 하위 문제는 배열에 저장하여 중복 계산 방지

```java
static int[] dp;

static int fibo(int x) {
    if (x == 1 || x == 2) return 1;
    if (dp[x] != 0) return dp[x];
    dp[x] = fibo(x - 1) + fibo(x - 2);
    return dp[x];
}
```

### 2. Bottom-up 방식 (상향식)

- 반복문을 사용하여 작은 문제부터 차례로 계산
- 점화식에 따라 배열 값을 채워나감

```java
static int[] dp;

static int fibo(int x) {
    dp[1] = 1;
    dp[2] = 1;
    for (int i = 3; i <= x; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[x];
}
```

---

## 핵심 용어

### 메모이제이션(Memoization)

- 이미 계산한 결과를 배열에 저장하여 동일한 계산을 반복하지 않음
- 재귀 + 메모이제이션이 Top-down 방식에서 사용됨

---

## Tip

- 동적계획법은 중복되는 부분 문제와 최적 부분 구조가 있는 문제에 사용 가능
- 구현은 Top-down(재귀 + 메모이제이션) 또는 Bottom-up(반복문 + DP 테이블)으로 가능
- 계산한 값을 저장해 중복 계산을 피함으로써 시간 복잡도를 줄임
- 점화식은 DP 계산 흐름의 핵심이므로 반드시 명확하게 수립해야 함
